
# Tracer (SPP Lab 1)

Многопоточный инструмент для профилирования и измерения времени выполнения методов в .NET приложениях. Поддерживает сериализацию результатов в форматы JSON, XML и YAML через систему динамически загружаемых плагинов.

## Обзор

Проект реализует библиотеку для трассировки методов, которая собирает информацию о времени выполнения, именах методов и классов, а также учитывает вложенность вызовов. Архитектура решения построена на принципах разделения ответственности и использует механизм плагинов для расширения форматов вывода данных.

### Ключевые возможности

*   **Измерение времени:** Использование `System.Diagnostics.Stopwatch` для точных замеров.
*   **Многопоточность:** Корректный сбор статистики из разных потоков с использованием потокобезопасных коллекций.
*   **Иерархия вызовов:** Построение дерева вызовов (Call Tree) для отображения вложенных методов.
*   **Плагинная архитектура:** Сериализаторы подключаются как внешние сборки (.dll) без изменения основного кода.
*   **Неизменяемость:** Результаты измерений предоставляются через read-only структуры данных.

## Технологический стек

*   **.NET 9** (C#)
*   **Reflection** (`System.Reflection`, `StackTrace`) — анализ стека вызовов.
*   **Concurrent Collections** — обеспечение потокобезопасности.
*   **Serialization Libraries**:
    *   `System.Text.Json`
    *   `System.Xml.Linq`
    *   `YamlDotNet`

## Архитектура решения

Проект разделен на следующие компоненты:

1.  **Tracer.Core**
    Основная библиотека. Содержит класс `Tracer`, реализующий интерфейс `ITracer`. Использует `ConcurrentDictionary` для хранения контекста каждого потока. Результат возвращается в виде неизменяемой структуры `TraceResult`.

2.  **Tracer.Serialization.Abstractions**
    Содержит контракт (интерфейс `ITraceResultSerializer`), который должен быть реализован всеми плагинами сериализации.

3.  **Tracer.Serialization**
    Библиотека для управления плагинами. Класс `PluginLoader` сканирует указанную директорию, загружает сборки через `Assembly.LoadFrom` и инстанцирует найденные сериализаторы.

4.  **Плагины (Tracer.Serialization.*)**
    Отдельные проекты (.Json, .Xml, .Yaml), реализующие логику сохранения данных в конкретный формат.

## Пример использования

### Базовый сценарий

```csharp
public void Execute()
{
    // 1. Инициализация
    ITracer tracer = new Tracer();

    // 2. Внедрение зависимости и замер
    var service = new MyService(tracer);
    
    tracer.StartTrace();
    service.DoWork();
    tracer.StopTrace();

    // 3. Получение результата
    TraceResult result = tracer.GetTraceResult();
}
```

### Результат работы (JSON)

Пример вывода для многопоточного приложения с вложенными методами:

```json
{
  "threads": [
    {
      "id": 1,
      "time": "181ms",
      "methods": [
        {
          "name": "MyMethod",
          "class": "Foo",
          "time": "181ms",
          "methods": [
            {
              "name": "InnerMethod",
              "class": "Bar",
              "time": "68ms",
              "methods": []
            }
          ]
        }
      ]
    }
  ]
}
```

## Сборка и запуск

### Сборка проекта

Выполните команду в корневой директории решения:

```bash
dotnet build
```

### Запуск демонстрационного приложения

Приложение `Tracer.Example` демонстрирует работу библиотеки в многопоточном режиме и сохраняет результаты во всех поддерживаемых форматах.

```bash
dotnet run --project Tracer.Example/Tracer.Example.csproj
```

После выполнения в директории приложения будут созданы файлы: `result.json`, `result.xml`, `result.yaml`.

### Запуск тестов

Для проверки корректности работы ядра (Unit-тесты):

```bash
dotnet test
```

## Структура репозитория

*   **Tracer.Core** — Логика измерения и формирования дерева вызовов.
*   **Tracer.Serialization.Abstractions** — Общие интерфейсы.
*   **Tracer.Serialization** — Логика загрузки плагинов.
*   **Tracer.Example** — Консольное приложение для демонстрации.
*   **Tracer.Core.Tests** — Модульные тесты.
*   **Tracer.Serialization.Json/Xml/Yaml** — Реализации плагинов.
